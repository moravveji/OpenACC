# Fortran Derived Types

## Purpose
This small project tries to exploit using Fortran 90 derived types, with allocatable arrays. The purpose is to manage the data transfer between the host and device through using the `!$acc enter data` and `!$acc exit data` clauses. The derived types contains necessary information for a 2-dimensional Gaussian curve (https://en.wikipedia.org/wiki/Gaussian_function). This example builds on the more simple example with [allocatable_arrays](https://github.com/moravveji/OpenACC/tree/master/allocatable_arrays), where no typed variables are used, and the variables are module-wide and defined in `vars.f90` file.

## Content
+ `vars.f90` module where the derived type and the data movement subroutines are defined
+ `kern.f90` module which contains the kernel for filling up the 2D Gaussian curve
+ `io.f90` module for a basic flushing of the data to an ASCII file for plotting
+ `main.f90` program file which `use`s the other two modules, moves the data around, and launches the kernel.
+ `plotter.py` for a simple plotting of the `gaussian2d.txt` file, to make sure that the 2D Gaussian bell curve looks OK on a coarse grid.

## Tips
+ A mistake I made was to compile each module with the `-c` flag, and link them all with the `-acc -ta=tesla:cuda8.0,cc35 -Minfo=accel` flags. However, the code does not execute on the device with this build. Instead, the entire `-acc -ta=tesla:cuda8.0,cc35 -Minfo=accel` should be used for compilation and linking, respectively.
+ The inline `do` loops must be avoided. E.g. the following 
```fortran 
a% x(1 : a% nx) = (/ (xlo + (k-1) * dx, k = 1, a% nx) /)
```
must be replaced by an explicit loop

```fortran 
do k = 1, a% nx
   a% x(k) = xlo + (k-1) * dx
enddo 
```
otherwise, the CUDA kernel cannot be generated by the compiler.

## Result
![image](gaussian2d.png)


